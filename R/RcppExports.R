# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

affineCFevalCpp <- function(coeffs, stateMat, retLog) {
    .Call('affineModelR_affineCFevalCpp', PACKAGE = 'affineModelR', coeffs, stateMat, retLog)
}

affineCFderivsEvalCpp <- function(coeffs, stateMat) {
    .Call('affineModelR_affineCFderivsEvalCpp', PACKAGE = 'affineModelR', coeffs, stateMat)
}

affineSimulateCpp <- function(TT_, BB_, parList_, dt_, initVals_, genPtr_, retainIndex_) {
    .Call('affineModelR_affineSimulateCpp', PACKAGE = 'affineModelR', TT_, BB_, parList_, dt_, initVals_, genPtr_, retainIndex_)
}

#' @export
generate_expNormJump <- function(jmpPar) {
    .Call('affineModelR_generate_expNormJump', PACKAGE = 'affineModelR', jmpPar)
}

#' @export
generate_kouExpJump <- function(jmpPar) {
    .Call('affineModelR_generate_kouExpJump', PACKAGE = 'affineModelR', jmpPar)
}

#' @export
generate_JT2010_cojump <- function(jmpPar) {
    .Call('affineModelR_generate_JT2010_cojump', PACKAGE = 'affineModelR', jmpPar)
}

#' @export
generate_JT2010_cojump_voljump <- function(jmpPar) {
    .Call('affineModelR_generate_JT2010_cojump_voljump', PACKAGE = 'affineModelR', jmpPar)
}

#' @export
generate_1sidedExp <- function(jmpPar) {
    .Call('affineModelR_generate_1sidedExp', PACKAGE = 'affineModelR', jmpPar)
}

jumpTransform <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransform', PACKAGE = 'affineModelR', beta, jmpPar)
}

jumpTransformD1 <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransformD1', PACKAGE = 'affineModelR', beta, jmpPar)
}

jumpTransformD2 <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransformD2', PACKAGE = 'affineModelR', beta, jmpPar)
}

jumpTransformD3 <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransformD3', PACKAGE = 'affineModelR', beta, jmpPar)
}

kouExpTransform <- function(beta, jmpPar) {
    .Call('affineModelR_kouExpTransform', PACKAGE = 'affineModelR', beta, jmpPar)
}

kouExpTransformD1 <- function(beta, jmpPar) {
    .Call('affineModelR_kouExpTransformD1', PACKAGE = 'affineModelR', beta, jmpPar)
}

kouExpTransformD2 <- function(beta, jmpPar) {
    .Call('affineModelR_kouExpTransformD2', PACKAGE = 'affineModelR', beta, jmpPar)
}

kouExpTransformD3 <- function(beta, jmpPar) {
    .Call('affineModelR_kouExpTransformD3', PACKAGE = 'affineModelR', beta, jmpPar)
}

jt2010_transform_CJ <- function(beta, jmpPar) {
    .Call('affineModelR_jt2010_transform_CJ', PACKAGE = 'affineModelR', beta, jmpPar)
}

jt2010_transform_CJ_VJ <- function(beta, jmpPar) {
    .Call('affineModelR_jt2010_transform_CJ_VJ', PACKAGE = 'affineModelR', beta, jmpPar)
}

jumpTransform_1sidedExp <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransform_1sidedExp', PACKAGE = 'affineModelR', beta, jmpPar)
}

jumpTransform_1sidedExp_2 <- function(beta, jmpPar) {
    .Call('affineModelR_jumpTransform_1sidedExp_2', PACKAGE = 'affineModelR', beta, jmpPar)
}

#' @title Make Positive Definite
#' @description Take a semi-positive definite matrix and use the eigenvalue decomposition to obtain the nearest positive definite matrix
#' @param semiDefMat semi-pos-def matrix, symmetric
#' @param relEig relative range of eigenvalues taken to define the pd matrix
#' @return matrix size of semiDefMat
#' @export
makePositiveDefinite <- function(semiDefMat, relEig = 1e-6) {
    .Call('affineModelR_makePositiveDefinite', PACKAGE = 'affineModelR', semiDefMat, relEig)
}

#'@export
getPointerToGenerator <- function(fstr) {
    .Call('affineModelR_getPointerToGenerator', PACKAGE = 'affineModelR', fstr)
}

#'@export
getPointerToJumpTransform <- function(fstr) {
    .Call('affineModelR_getPointerToJumpTransform', PACKAGE = 'affineModelR', fstr)
}

#'@export
evaluateGenerator <- function(genPtr_, jmpPar) {
    .Call('affineModelR_evaluateGenerator', PACKAGE = 'affineModelR', genPtr_, jmpPar)
}

#'@export
evaluateTransform <- function(genPtr_, beta, jmpPar) {
    .Call('affineModelR_evaluateTransform', PACKAGE = 'affineModelR', genPtr_, beta, jmpPar)
}

